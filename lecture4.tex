\documentclass[12pt,t]{beamer}

\beamertemplatenavigationsymbolsempty

% usepackage
%\usepackage{template/dbt}
\usepackage{listings,graphics}

\definecolor{comments}{RGB}{81,81,81}
\definecolor{keywords}{RGB}{255,0,90}

% lstlisting
\lstset{
    language=C,
    basicstyle=\footnotesize\ttfamily,
    keywordstyle=\color{keywords},
    showspaces=false,
    showstringspaces=false,
    commentstyle=\color{blue}\emph
    %frame=single,
    %rulecolor=\color{comments},
    %rulesepcolor=\color{comments},
    %backgroundcolor = \color{lightgray}
}

\usetheme{default}

\usepackage[
    type={CC},
    modifier={by-nc-nd},
    version={4.0},
]{doclicense} 

\input{template/variables.tex}

% frame slide
\title{\coursename}
\subtitle{Lecture 4: N-Body simulations, Structs, Classes, and generic functions}

%\author{\href{}{}}
%\institute {
%    \href{}{\tt \scriptsize \today}
%}
\date {
 \tiny \url{https://www.cct.lsu.edu/~pdiehl/teaching/2019/4977/}
\vspace{2cm}
\doclicenseThis  
  
}



\usepackage{ifxetex}
\usepackage{tikz}

\ifxetex
\usepackage{fontspec}
\setmainfont{Raleway}
\fi

\begin{document} {
    \setbeamertemplate{footline}{}
    \frame {
        \titlepage
    }
}

\frame{

\tableofcontents

}

\AtBeginSection[]{
  \begin{frame}
  \vfill
  \centering
  \begin{beamercolorbox}[sep=8pt,center,shadow=true,rounded=true]{title}
    \usebeamerfont{title}\insertsectionhead\par%
  \end{beamercolorbox}
  \vfill
  \end{frame}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Reminder}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}{Lecture 3}
\begin{block}{What you should know from last lecture}
\begin{itemize}
\item Iterators
\item Lists
\item Library algorithms
\item Numerical limits
\item Reading and Writing files
\end{itemize}
\end{block}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{$N$-body simulations}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}{$N$-body simulations\footnote{\tiny By Michael L. Umbricht - Own work, CC BY-SA 4.0}}

\begin{figure}
\includegraphics[width=0.5\linewidth]{./images/Galaxy_cluster_sim.png}
\end{figure}


The $N$-body problem is the physically problem of predicting the individual motions of a group of celestial objects interacting with each other gravitationally.

\begin{block}{Informal description:}
Predict the interactive forces and true orbital motions for all future times of a group of celestial bodies. We assume that we have their quasi-steady orbital properties, e.g.\ instantaneous position, velocity and time.
\end{block}

\end{frame}


\begin{frame}{Recall: Vectors and basic operations}


\begin{block}{Vectors}
\centering
$\mathbf{u}=(x,y,z)\in \mathbb{R}^3$\\
\begin{enumerate}
\item Norm: $\vert \mathbf{u} \vert = \sqrt{x^2+y^2+z^2}$
\item Direction: $\frac{\mathbf{u}}{\vert \mathbf{u}\vert}$
\end{enumerate}
\end{block}
\begin{block}{Inner product}
\centering
$\mathbf{u}_1 \circ \mathbf{u}_2 = x_1x_2 + y_1y_2 + z_1z_2 $
\end{block}
\begin{block}{Cross product}
\centering
$\mathbf{u}_1 \times \mathbf{u}_2 = \vert\mathbf{u}_1 \vert \vert\mathbf{u}_2 \vert sin(\theta)  $
\end{block}

\end{frame}

\begin{frame}{Stepping back: Two-body problem}
Let $m_1,m_2$ be the masses of two gravitational bodies at the positions $\mathbf{r}_1,\mathbf{r}_2\in\mathbb{R}^3$

\begin{block}{Three key laws:}
\begin{enumerate}
\item The Law of Gravitation: The force of $m_1$ acting on $m_2$ is \\
$\mathbf{F}_{12}= G m_1 m_2 \frac{\mathbf{r}_1-\mathbf{r}_2}{\vert \mathbf{r}_1-\mathbf{r}_2 \vert^3}$
\item The Calculus: 
\begin{enumerate}
\item The velocity of $m_1$ is $\mathbf{v}_1 = \frac{d \mathbf{r}_1}{dt}$
\item The acceleration of $m_1$ is $\mathbf{a}_1 \frac{d \mathbf{v}_1}{dt}$
\end{enumerate}
\item The second Law of Mechanics: \\
 $\mathbf{F}= m \mathbf{a}$ (Force is equal mass times acceleration)
\end{enumerate}
\end{block}
The universal constant of gravitation $G$ was estimated as $6.67408\cdot 10^{-11}m^3kg^{-1}s^{-2}$ in 2014~\cite{mohr2016codata}.
\end{frame}



\begin{frame}{Put all together: Equation of motion}
Derivation for the first body:
\begin{columns}
\begin{column}{0.5\textwidth}
\begin{align*}
\mathbf{F}&=G m_1 m_2 \frac{\mathbf{r}_1-\mathbf{r}_2}{\vert \mathbf{r}_1-\mathbf{r}_2 \vert^3}  \\
m_1 \mathbf{a}_i &= G m_1 m_2 \frac{\mathbf{r}_1-\mathbf{r}_2}{\vert \mathbf{r}_1-\mathbf{r}_2 \vert^3} \\
\frac{d \mathbf{v}_1}{dt} & = G m_2 \frac{\mathbf{r}_1-\mathbf{r}_2}{\vert \mathbf{r}_1-\mathbf{r}_2 \vert^3} \\
\frac{d^2 \mathbf{r}_1}{dt^2} & = G m_2 \frac{\mathbf{r}_1-\mathbf{r}_2}{\vert \mathbf{r}_1-\mathbf{r}_2 \vert^3}
\end{align*}
\end{column}
\begin{column}{0.5\textwidth}  %%<--- here
    \begin{center}
    \begin{tikzpicture}
\draw (-2,0) circle (0.5cm);
\draw (2,0) circle (0.275cm);
\node at (-2,0) {$m_1$};
\node at (2,0) {$m_2$};
\draw[->] (-1.5,0)--(-1,0);
\draw[->] (1.7,0)--(1,0);
\node[below] at (-1,0) {$\mathbf{F}_1$};
\node[below] at (1,0) {$\mathbf{F}_2$};
\end{tikzpicture}
     \end{center}
\end{column}
\end{columns} 
\vspace{0.5cm}
For the second body follows:
$\frac{d^2 \mathbf{r}_2}{dt^2}  = G m_1 \frac{\mathbf{r}_1-\mathbf{r}_2}{\vert \mathbf{r}_1-\mathbf{r}_2 \vert^3}$ \\
\vspace{0.5cm}
Note that we used Newton's law of universal gravitation~\cite{newton1833philosophiae}.

\end{frame}

\begin{frame}{The $N$-body problem}

\begin{block}{Equation of motion}
$ m_i \frac{d^2 \mathbf{r}_i}{d t^2} = \sum\limits_{j=1}^n G m_i m_j \frac{\mathbf{r}_j - \mathbf{r}_i}{\vert \mathbf{r}_j - \mathbf{r}_i\vert^3} $
\end{block}

\begin{block}{Law of Conservation:}
\begin{enumerate}
\item Linear Momentum: $\sum\limits_{i=1}^n m_i \mathbf{v}_i = M_0$
\item Center of Mass: $\sum\limits_{i=1}^n m_i \mathbf{r}_i = M_0 t + M_1$
\item Angular Momentum: $\sum\limits_{i=1}^n m_i (\mathbf{r}_i \times \mathbf{v}_i) = \mathbf{c}$
\item Energy: T-U=h with \\
$ T = \frac{1}{2} \sum\limits_{i=1}^n m_i \mathbf{v}_i \circ \mathbf{v}_i  , U= \sum\limits_{i=1}^n \sum\limits_{j=1}^n G \frac{m_i m_j}{\vert\mathbf{r}_i - \mathbf{r}_j\vert} $
\end{enumerate}
\end{block}
More details: Simulations~\cite{aarseth2003gravitational} and Astrophysics~\cite{aarseth2008cambridge}.
\end{frame}

\begin{frame}[fragile]{Complexity}

\begin{block}{Force computation: Direct sum}
\begin{lstlisting}
for(size_t i = 0; i < bodies.size(); i++)
for(size_t j = 0; j < bodies.size(); j++)
//Compute forces
\end{lstlisting}
\end{block}

\begin{block}{Advantage:}
Robust, accurate, and completely general
\end{block}

\begin{block}{Disadvantage:}
\begin{enumerate}
\item Computational cost per body $\mathcal{O}(n)$ 
\item Computational cost for all bodies $\mathcal{O}(n^2)$ 
\end{enumerate}
\end{block}
Tree-based codes reduce the computational costs to $\mathcal{O}(n\log(n))$. More details~\cite{knuth1997art}.
\end{frame}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Structs}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]{Looking at the data structure\footnote{\tiny\url{https://en.cppreference.com/w/c/language/struct}}}
For the $N$-body simulations, we need three dimensional vectors having
\begin{columns}
\begin{column}{0.5\textwidth}
\begin{itemize}
\item $x$ Coordinate
\item $y$ Coordinate
\item $z$ Coordinate
\end{itemize}
\end{column}
\begin{column}{0.5\textwidth}  %%<--- here
\begin{lstlisting}
struct vector {
double x;
double y;
double z;
};
\end{lstlisting}
\end{column}
\end{columns} 
\begin{block}{Initialization}
\lstinline|struct vector v = {.x=1, .y=1, .z=1};| \\
\lstinline|struct vector v1 = {1,1,1};|
\end{block}

\begin{block}{Reading/Writing elements }
\lstinline|std::cout << v.x << std:endl;| \\
\lstinline|v.z=42;|
\end{block}
\end{frame}

\begin{frame}[fragile]{Constructor\footnote{\tiny\url{https://en.cppreference.com/w/cpp/language/default_constructor}}}
\begin{block}{Assign initial values}
\begin{lstlisting}
struct A
{
    int x;
    A(int x = 1): x(x) {};
};
\end{lstlisting}
\end{block}

\begin{block}{A constructor has a}
\begin{itemize}
\item Name \lstinline|A| 
\item Arguments \lstinline|int x = 1|
\item Assignment \lstinline|: x(x)|
\end{itemize}
Now \lstinline|struct A a;| is equivalent to \lstinline|struct A a = {1}|;
\end{block}

\end{frame}


\begin{frame}[fragile]{Functions\footnote{\tiny\url{https://en.cppreference.com/w/cpp/language/functions}}}
\begin{block}{Compute the norm of the vector}
\begin{lstlisting}
#include <cmath>
struct vector2 {
double x , y , z;
vector2(double x = 0, double y=0, double z=0)
	: x(x) , y(y) ,z(z) {}
double norm(){ return std::sqrt(x*x+y*y+z*z);}
}
\end{lstlisting}
\end{block}

\begin{block}{Usage}
\begin{lstlisting}
struct vector v;
std::cout << v.norm{} << std::endl;
\end{lstlisting}
\end{block}
Note: \lstinline|#include <cmath>|\footnote{\tiny\url{https://en.cppreference.com/w/cpp/header/cmath}} provides mathematical expressions
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Generic programming}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]{Why we need generic functions?}

\begin{block}{Example}
\begin{lstlisting}
//Compute the sum of two double values
double add(double a, double x) {
return a + b;
}
//Compute the sum of two float values
float add(float a, float x) {
return a + b;
}
\end{lstlisting}
\end{block}

\begin{block}{Reasons:}
\begin{itemize}
\item We have less redundant code
\item The C++ standard library makes large usage of generic programming, \emph{e.g.} \lstinline|std::vector<double>|, \lstinline|std::vector<float>|
\end{itemize}
\end{block}

\end{frame}

\begin{frame}[fragile]{Function template\footnote{\tiny\url{https://en.cppreference.com/w/cpp/language/function_template}}}

\begin{block}{Writing a generic function:}
\begin{lstlisting}
template<typename T>
T add(T a, T b)
{
return a + b;
}
\end{lstlisting}
\end{block}

\begin{block}{Using the generic function:}
\begin{lstlisting}
std::cout << add<double>(2.0,1.0) << std::endl;
std::cout << add<int>(2,1) << std::endl;
std::cout << add<float>(2.0,1.0) << std::endl;
\end{lstlisting}
\end{block}

\begin{block}{Additional way to use the generic function:}
\begin{lstlisting}
std::cout << add(2,1) << std::endl;
\end{lstlisting}
\end{block}

\end{frame}


\begin{frame}[fragile]{Generic structs\footnote{\tiny\url{https://en.cppreference.com/w/cpp/language/templates}}}

\begin{block}{Writing a generic vector type}
\begin{lstlisting}
template<typename T>
struct vector {
T x;
T y;
T z;
};
\end{lstlisting}
\end{block}

\begin{block}{Using a generic vector type}
\begin{lstlisting}
struct vector<double> vd = {1,2,3};
struct vector<float> vf = {1,2,3};
struct vector<int> vi = {1,2,3};
\end{lstlisting}
\end{block}
\end{frame}


\begin{frame}[fragile]{Example}
\begin{block}{Generic struct having functions}
\begin{lstlisting}
#include <cmath>

template<typename T>
struct vector {
T x , y , z;
vector( T x = 0, T y=0, T z=0)
	: x(x) , y(y) ,z(z) {}
T norm() { return std::sqrt(x*x+y*y+z*z);}
T cross(struct vector<T> b)
{return x*b.x+y*b.y+z*b.z;}
};
\end{lstlisting}
\end{block}

\begin{block}{What we need to define the vector data structure:}
\begin{itemize}
\item Structs
\item Generic functions
\end{itemize}
\end{block}

\end{frame}





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Summary}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{References}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[t, allowframebreaks]
\frametitle{References}
\bibliographystyle{plain}
\bibliography{bib}
\end{frame}

\end{document}